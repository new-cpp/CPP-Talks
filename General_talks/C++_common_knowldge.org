#+TITLE: C++ common knowldge by Dawid Zalewski
** talk major points:
 1. Uninitialized means indeterminate.
 2. Declaration order is initialization.
 3. Assignment is not initialialization.
 4. Implicit conversions are almost always evil.
 5. Everything need to be defined once.
 6. Only fully constructed objects benefit from RAII.
 7. RAII means: one class, one resource.
 8. Member functions have an extra this paramerter.
 9. Const member functions have const this paramerter.
 10. Hidden friends are there to help you.
 11. Polymorphic classes need virtual destructors.
 12. Be careful when passing derived classes by copy.

** major points with example code:
1. Uninitialized means indeterminate.

  Bad one:
    #+begin_src cpp
       struct named_collection_base
       {
         std::string name; // random initial value garbage!!
         std::size_t size; // same !!
         named_collection_base(){} // useless user provided ctor !!
       }
       name_collection_base ncb{};

       std::cout<<ncb.name; //OK ,the compiler will code a default ctor for         std::string

       std::cout<<ncb.size; // UB
    #+end_src

   Good one:
   - get ride of the useless Ctor.
   - the braces initialization of ncb obj is great!!!
   - put the braces somewhere e.g. in class

   #+begin_src cpp
    struct named_collection_base
       {
         std::string name{};
         std::size_t size{};
        named_collection_base(){} // useless user provided ctor !!
       }
       name_collection_base ncb;

       std::cout<<ncb.name; //OK ,the compiler will code a default ctor for         std::string

       std::cout<<ncb.size; // UB

   #+end_src
2. Declaration order is initialization order
   Bad one:

   - in the bad example capacity in data_min, and data_max allocation,
     has indeterminate value. cuz declaration order is initiazation order.

   #+begin_src cpp
    template < typename t>
    struct named_heap : named_collection_base
    {
      name_heap():
        capacity { 16zu },
        data_min { new T[capacity] },
        data_max { new T[capacity] }
        {  }

      T* data_min;
      T* data_max;
      std::size_t capacity;
    }
   #+end_src

   Good one:

   #+begin_src cpp
    template < typename t>
    struct named_heap : named_collection_base
    {
      name_heap():

        data_min { new T[capacity] },
        data_max { new T[capacity] }
        {  }

      std::size_t capacity { 16 zu };
      T* data_min {};
      T* data_max {};

    }
   #+end_src
3. Assignment is not initialization

   Bad One :
   - the compiler initialze the underlyine named_collection_base obj
     + you overwriting the name paramerter in the body of the ctor
       a bit wastefull.
   #+begin_src cpp
template < typename t>
    struct named_heap : named_collection_base
    {
      name_heap(std::strin name):
        // named_collection_base{} called by the compiler
        data_min { new T[capacity] },
        data_max { new T[capacity] }
        {
          named_collection_base::name = std::move(name);// not place to initialization
        }

      T* data_min{};
      T* data_max{};
      std::size_t  capacity { 16zu };
    }
   #

   #+end_src

   Good one:
   #+begin_src cpp
template < typename t>
    struct named_heap : named_collection_base
    {
      name_heap(std::strin name):
        named_collection_base{std::move(name)},
        data_min { new T[capacity] },
        data_max { new T[capacity] }
        {

        }
      std::size_t  capacity { 16zu };
      T* data_min{};
      T* data_max{};

    }


   #+end_src

4. Implicit conversions are almost always evil

   1- Bad one:
    - Class_Name(T)(name_heap(std::string name)): are call converting ctor.
    - passing a string to a function with name_heap<T> type ... compiler allow it
     CUZ of the implicit conversions.

   #+begin_src cpp
template < typename t>
    struct named_heap : named_collection_base
    {
      name_heap(std::string name):
        named_collection_base{.name = std::move(name)},
        data_min { new T[capacity] },
        data_max { new T[capacity] }
        {

        }
      /* --- */
    }
named_heap<double> heap = "string literal"s; //weird
   #+end_src

  Good one:
  mark the ctor explicit
   #+begin_src cpp
    template < typename t>
    struct named_heap : named_collection_base
    {
      explicit name_heap(std::string name):
        named_collection_base{.name = std::move(name)},
        data_min { new T[capacity] },
        data_max { new T[capacity] }
        {

        }
      /* --- */
    }

   #+end_src

  2- Bad one:
  - implicit converting operators: class C { operator type()const{/*---*/} }
  - line 190 @:  comparing 2 ptr to named_collection_base??? we don't have a compare operator, but name_collection_base has a covertion operator to named_object that can be compared.

    #+begin_src cpp

   std::unique_ptr<name_collection_base> heap{new named_heap<double>{"heap"}};
   auto copy = std::make_unique<named_collection_base>(*heap);

   if(*copy == *heap)/*@*/
     {
       need_a_collection(std::move(copy));
     }

    //
   template< typename T>
   struct named_heap:named_collection_base;

   struct named_collection_base
   {
     std::string name;
     std::size_t size;
     named_collection_base(){};
     operator named_object()const {return { name };}
   };

    bool operator ==(const named_object& a , const named_object& b);
    #+end_src

 -Good one:
 - just mark the operator explicit.
   #+begin_src cpp
    struct named_collection_base
    {
      /* --- */
      explicit operator named_object()const { return named; }
    };
   #+end_src
5. Everything needs to be defined one (ODR)
